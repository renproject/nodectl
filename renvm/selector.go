package renvm

import (
	"encoding/json"
	"math/rand"
	"reflect"
	"regexp"
	"strings"

	"github.com/renproject/multichain"
	"github.com/renproject/surge"
)

const (
	// SyncWithChainFn is an intrinsic function that is generated by block
	// proposers when updating the state for a contract.
	SyncWithChainFn = "syncWithChain"

	// ChangeFeesFn is an intrinsic function that is generated by block
	// proposers when updating the mint or burn fees for a host chain.
	ChangeFeesFn = "changeFees"

	// EpochFn is an intrinsic function that is generated by block proposers
	// upon detecting a new epoch.
	EpochFn = "epoch"

	// ReturnStateAndOutputsFn is an extrinsic function that is generated by a
	// shard once it has finished processing transactions in a block.
	ReturnStateAndOutputsFn = "returnStateAndOutputs"

	// ClaimFeesFn is an extrinsic function that is used by Darknode operators
	// to request unclaimed fees earned by their Darknode.
	ClaimFeesFn = "claimFees"
)

var (
	// RegExToDestinationFromSource captures chains from selectors that
	// explicitly define their destination and source chains. This regex must be
	// matched before attempting to match RegExToDestination or
	// RegExToFromSource.
	RegExToDestinationFromSource = regexp.MustCompile(`/to(.*)From(.*)`)
	// RegExToDestination captures the destination chain from selectors that
	// explicitly define their destination chain. This regex does not work, but
	// will not error, if the selector also explicitly defines a source chain.
	// To prevent this, always try and match RegExToDestinationFromSource first.
	RegExToDestination = regexp.MustCompile(`/to(.*)`)
	// RegExFromSource captures the source chain from selectors that explicitly
	// define their source chain. This regex does not work, but will not error,
	// if the selector also explicitly defines a destination chain. To prevent
	// this, always try and match RegExToDestinationFromSource first.
	RegExFromSource = regexp.MustCompile(`/from(.*)`)
)

var (
	// IntrinsicSelectors is a list of selector functions for intrinsic
	// transactions.
	IntrinsicSelectors []string = []string{
		ChangeFeesFn,
		SyncWithChainFn,
		EpochFn,
	}
)

// A Selector identifies a specific function from a specific contract. The
// contract comes first, and the function comes second, separated by "/". For
// example, sending BTC to Ethereum is done by sending a cross-chain
// transactions to the "BTC/toEthereum" selector.
type Selector string

// Contract returns the contract component of the selector.
func (selector Selector) Contract() string {
	chunks := strings.Split(string(selector), "/")
	if len(chunks) != 2 {
		return ""
	}
	return chunks[0]
}

// Fn returns the function component of the selector.
func (selector Selector) Fn() string {
	chunks := strings.Split(string(selector), "/")
	if len(chunks) != 2 {
		return ""
	}
	return chunks[1]
}

// Asset moving from the source chain to the destination chain.
func (selector Selector) Asset() multichain.Asset {
	chunks := strings.Split(string(selector), "/")
	if len(chunks) != 2 {
		return multichain.Asset("")
	}
	return multichain.Asset(chunks[0])
}

// Source returns the chain from which assets are moving. For example,
// "BTC/toEthereum" selector has "Bitcoin" as its source chain, and
// "BTC/fromEthereum" selector has "Ethereum" as its source chain.
func (selector Selector) Source() multichain.Chain {
	// Match selectors like "BTC/toEthereumFromAcala"
	matches := RegExToDestinationFromSource.FindStringSubmatch(string(selector))
	if len(matches) > 0 {
		if len(matches) != 3 {
			return multichain.Chain("")
		}
		return multichain.Chain(matches[2])
	}
	// Match selectors like "BTC/fromEthereum"
	matches = RegExFromSource.FindStringSubmatch(string(selector))
	if len(matches) > 0 {
		if len(matches) != 2 {
			return multichain.Chain("")
		}
		return multichain.Chain(matches[1])
	}
	// Match selectors like "BTC/toEthereum"
	matches = RegExToDestination.FindStringSubmatch(string(selector))
	if len(matches) > 0 {
		if len(matches) != 2 {
			return multichain.Chain("")
		}
		return selector.Asset().OriginChain()
	}
	// Default to the empty string.
	return multichain.Chain("")
}

// Destination returns the chain to which assets are moving. For example,
// "BTC/toEthereum" selector has "Ethereum" as its destination chain, and
// "BTC/fromEthereum" selector has "Bitcoin" as its destination chain.
func (selector Selector) Destination() multichain.Chain {
	// Match selectors like "BTC/toEthereumFromAcala"
	matches := RegExToDestinationFromSource.FindStringSubmatch(string(selector))
	if len(matches) > 0 {
		if len(matches) != 3 {
			return multichain.Chain("")
		}
		return multichain.Chain(matches[1])
	}
	// Match selectors like "BTC/toEthereum"
	matches = RegExToDestination.FindStringSubmatch(string(selector))
	if len(matches) > 0 {
		if len(matches) != 2 {
			return multichain.Chain("")
		}
		return multichain.Chain(matches[1])
	}
	// Match selectors like "BTC/fromEthereum"
	matches = RegExFromSource.FindStringSubmatch(string(selector))
	if len(matches) > 0 {
		if len(matches) != 2 {
			return multichain.Chain("")
		}
		return selector.Asset().OriginChain()
	}
	// Default to the empty string.
	return multichain.Chain("")
}

// IsLock returns true if the asset is being locked into RenVM on its origin
// chain. This is true for lock-and-mint transactions.
func (selector Selector) IsLock() bool {
	asset := selector.Asset()
	source := selector.Source()
	return asset != "" && source != "" && asset.OriginChain() == source
}

// IsRelease returns true if the asset is being released from RenVM back to its
// origin chain. This is true for burn-and-release transactions.
func (selector Selector) IsRelease() bool {
	asset := selector.Asset()
	destination := selector.Destination()
	return asset != "" && destination != "" && asset.OriginChain() == destination
}

// IsMint returns true if the asset is being minted to a host chain. This is
// true for lock-and-mint and burn-and-mint transactions.
func (selector Selector) IsMint() bool {
	asset := selector.Asset()
	destination := selector.Destination()
	return asset != "" && destination != "" && asset.OriginChain() != destination
}

// IsBurn returns true if the asset is being burned from a host chain. This is
// true for burn-and-release and burn-and-mint transactions.
func (selector Selector) IsBurn() bool {
	asset := selector.Asset()
	source := selector.Source()
	return asset != "" && source != "" && asset.OriginChain() != source
}

// IsIntrinsic returns true if the selector is for an intrinsic tx.
func (selector Selector) IsIntrinsic() bool {
	for _, intrinsicSelector := range IntrinsicSelectors {
		if selector.Fn() == intrinsicSelector {
			return true
		}
	}
	return false
}

// IsCrossChain returns true if the selector is for a cross-chain tx.
func (selector Selector) IsCrossChain() bool {
	return selector.IsLock() || selector.IsRelease() || selector.IsMint() || selector.IsBurn()
}

// IsReturnStateAndOutputs returns true if the selector is for a
// return-state-and-outputs tx.
func (selector Selector) IsReturnStateAndOutputs() bool {
	return selector.Fn() == ReturnStateAndOutputsFn
}

// IsClaimFees returns true if the selector is for a claim fees tx.
func (selector Selector) IsClaimFees() bool {
	return selector.Fn() == ClaimFeesFn
}

// SizeHint returns the number of bytes required to represent the selector in
// binary.
func (selector Selector) SizeHint() int {
	return surge.SizeHint(string(selector))
}

// Marshal the selector into binary.
func (selector Selector) Marshal(buf []byte, rem int) ([]byte, int, error) {
	return surge.MarshalString(string(selector), buf, rem)
}

// Unmarshal the selector from binary.
func (selector *Selector) Unmarshal(buf []byte, rem int) ([]byte, int, error) {
	var str string
	buf, rem, err := surge.UnmarshalString(&str, buf, rem)
	if err != nil {
		return buf, rem, err
	}
	*selector = Selector(str)
	return buf, rem, nil
}

// MarshalJSON implements the JSON marshaler interface.
func (selector Selector) MarshalJSON() ([]byte, error) {
	return json.Marshal(string(selector))
}

// UnmarshalJSON implements the JSON unmarshaler interface.
func (selector *Selector) UnmarshalJSON(data []byte) error {
	var str string
	if err := json.Unmarshal(data, &str); err != nil {
		return err
	}
	*selector = Selector(str)
	return nil
}

func (selector Selector) String() string {
	return string(selector)
}

// Generate allows us to quickly generate random transaction selectors. This is
// mostly used for writing tests.
func (Selector) Generate(r *rand.Rand, size int) reflect.Value {
	if size > 10 {
		size = 10
	}
	alphabet := "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

	// Asset prefix
	b := new(strings.Builder)
	for i := 0; i < 3; i++ {
		b.WriteByte(alphabet[r.Int()%len(alphabet)])
	}
	b.WriteString("/")

	switch r.Int() % 3 {
	case 0: // to
		b.WriteString("to")
		for i := 0; i < size; i++ {
			b.WriteByte(alphabet[r.Int()%len(alphabet)])
		}
	case 1: // from
		b.WriteString("from")
		for i := 0; i < size; i++ {
			b.WriteByte(alphabet[r.Int()%len(alphabet)])
		}
	case 2: // toFrom
		b.WriteString("to")
		for i := 0; i < size/2; i++ {
			b.WriteByte(alphabet[r.Int()%len(alphabet)])
		}
		b.WriteString("From")
		for i := 0; i < size/2; i++ {
			b.WriteByte(alphabet[r.Int()%len(alphabet)])
		}
	}
	return reflect.ValueOf(Selector(b.String()))
}
